import configureMockStore from 'redux-mock-store'
import {thunk} from 'redux-thunk'
import {getOrder} from '../api';
import reducer, {
  initialState,
  setCurrentOrder,
  clearCurrentOrder,
  openModalOrder,
  closeModalOrderDetails
} from './currentOrderSlice';
import fetchMock from 'fetch-mock';
import { fetchOrderById } from './currentOrderRequests';

const middlewares = [thunk];
const mockStore = configureMockStore(middlewares);
const testOrder = {
  ingredients: ['60666c42cc7b410027a1a9b1', '60666c42cc7b410027a1a9b1'],
  _id: '1',
  status: 'done',
  name: 'Test Order',
  number: 1,
  createdAt: '2024-01-01T00:00:00Z',
  updatedAt: '2024-01-01T00:00:00Z',
  openModal: false,
  isLoading: false,
  error: ''
};

describe('currentOrderSlice reducer', () => {
  it('should return the initial state', () => {
    expect(reducer(undefined, { type: 'unknown' })).toEqual(initialState);
  });

  it('should handle setCurrentOrder action', () => {
    const payload = testOrder;
    const expectedState = {
      ...initialState,
      ...payload
    };
    expect(reducer(initialState, setCurrentOrder(payload))).toEqual(expectedState);
  });

  it('should handle clearCurrentOrder action', () => {
    const modifiedState = {
      ...initialState,
      ...testOrder
    };
    expect(reducer(modifiedState, clearCurrentOrder())).toEqual(initialState);
  });

  it('should handle openModalOrder action', () => {
    const payload = {
      ...testOrder,
      openModal: true
    };
    const expectedState = {
      ...initialState,
      ...payload
    };
    expect(reducer(initialState, openModalOrder(payload))).toEqual(expectedState);
  });

  it('should handle closeModalOrderDetails action', () => {
    const modifiedState = {
      ...initialState,
      ...testOrder,
      openModal: true
    };
    expect(reducer(modifiedState, closeModalOrderDetails())).toEqual(initialState);
  });

});
describe('fetchOrderById async actions', () => {
  afterEach(() => {
    fetchMock.restore();
  });

  it('creates fetchOrderById.fulfilled when fetching order has been done action', async () => {
    const store = mockStore({ currentOrder: initialState });
    const orderNum = '1';
    const payload = { orders: [testOrder] };

    fetchMock.getOnce(`${getOrder}${orderNum}`, {
      body: payload,
      headers: { 'content-type': 'application/json' }
    });

    const expectedActions = [
      { type: fetchOrderById.pending.type },
      { type: fetchOrderById.fulfilled.type, payload }
    ];

    await store.dispatch(fetchOrderById(orderNum));
    expect(store.getActions()).toEqual(expectedActions);
  });

  it('creates fetchOrderById.rejected when fetching order fails action', async () => {
    const store = mockStore({ currentOrder: initialState });
    const orderNum = '1';
    const error = 'Failed to fetch order';

    fetchMock.getOnce(`${getOrder}${orderNum}`, {
      throws: new Error(error)
    });

    const expectedActions = [
      { type: fetchOrderById.pending.type },
      { type: fetchOrderById.rejected.type, error: { message: error } }
    ];

    await store.dispatch(fetchOrderById(orderNum));
    expect(store.getActions()).toEqual(expectedActions);
  });
});